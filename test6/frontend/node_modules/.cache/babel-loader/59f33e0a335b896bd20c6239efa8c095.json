{"ast":null,"code":"import { render, unmountComponentAtNode } from 'react-dom';\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\"; // We only handle element & text node.\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar ellipsisContainer;\nvar wrapperStyle = {\n  padding: 0,\n  margin: 0,\n  display: 'inline',\n  lineHeight: 'inherit'\n};\n\nfunction pxToNumber(value) {\n  if (!value) return 0;\n  var match = value.match(/^\\d*(\\.\\d*)?/);\n  return match ? Number(match[0]) : 0;\n}\n\nfunction styleToString(style) {\n  // There are some different behavior between Firefox & Chrome.\n  // We have to handle this ourself.\n  var styleNames = Array.prototype.slice.apply(style);\n  return styleNames.map(function (name) {\n    return \"\".concat(name, \": \").concat(style.getPropertyValue(name), \";\");\n  }).join('');\n}\n\nfunction mergeChildren(children) {\n  var childList = [];\n  children.forEach(function (child) {\n    var prevChild = childList[childList.length - 1];\n\n    if (typeof child === 'string' && typeof prevChild === 'string') {\n      childList[childList.length - 1] += child;\n    } else {\n      childList.push(child);\n    }\n  });\n  return childList;\n}\n\nexport default (function (originEle, rows, content, fixedContent, ellipsisStr) {\n  if (!ellipsisContainer) {\n    ellipsisContainer = document.createElement('div');\n    ellipsisContainer.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(ellipsisContainer);\n  } // Get origin style\n\n\n  var originStyle = window.getComputedStyle(originEle);\n  var originCSS = styleToString(originStyle);\n  var lineHeight = pxToNumber(originStyle.lineHeight);\n  var maxHeight = lineHeight * (rows + 1) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom); // Set shadow\n\n  ellipsisContainer.setAttribute('style', originCSS);\n  ellipsisContainer.style.position = 'fixed';\n  ellipsisContainer.style.left = '0';\n  ellipsisContainer.style.height = 'auto';\n  ellipsisContainer.style.minHeight = 'auto';\n  ellipsisContainer.style.maxHeight = 'auto';\n  ellipsisContainer.style.top = '-999999px';\n  ellipsisContainer.style.zIndex = '-1000'; // clean up css overflow\n\n  ellipsisContainer.style.textOverflow = 'clip';\n  ellipsisContainer.style.whiteSpace = 'normal';\n  ellipsisContainer.style.webkitLineClamp = 'none'; // Render in the fake container\n\n  var contentList = mergeChildren(toArray(content));\n  render(React.createElement(\"div\", {\n    style: wrapperStyle\n  }, React.createElement(\"span\", {\n    style: wrapperStyle\n  }, contentList), React.createElement(\"span\", {\n    style: wrapperStyle\n  }, fixedContent)), ellipsisContainer); // wrap in an div for old version react\n  // Check if ellipsis in measure div is height enough for content\n\n  function inRange() {\n    return ellipsisContainer.offsetHeight < maxHeight;\n  } // Skip ellipsis if already match\n\n\n  if (inRange()) {\n    unmountComponentAtNode(ellipsisContainer);\n    return {\n      content: content,\n      text: ellipsisContainer.innerHTML,\n      ellipsis: false\n    };\n  } // We should clone the childNode since they're controlled by React and we can't reuse it without warning\n\n\n  var childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter(function (_ref) {\n    var nodeType = _ref.nodeType;\n    return nodeType !== COMMENT_NODE;\n  });\n  var fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n  unmountComponentAtNode(ellipsisContainer); // ========================= Find match ellipsis content =========================\n\n  var ellipsisChildren = [];\n  ellipsisContainer.innerHTML = ''; // Create origin content holder\n\n  var ellipsisContentHolder = document.createElement('span');\n  ellipsisContainer.appendChild(ellipsisContentHolder);\n  var ellipsisTextNode = document.createTextNode(ellipsisStr);\n  ellipsisContentHolder.appendChild(ellipsisTextNode);\n  fixedNodes.forEach(function (childNode) {\n    ellipsisContainer.appendChild(childNode);\n  }); // Append before fixed nodes\n\n  function appendChildNode(node) {\n    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n  } // Get maximum text\n\n\n  function measureText(textNode, fullText) {\n    var startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;\n    var lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var midLoc = Math.floor((startLoc + endLoc) / 2);\n    var currentText = fullText.slice(0, midLoc);\n    textNode.textContent = currentText;\n\n    if (startLoc >= endLoc - 1) {\n      // Loop when step is small\n      for (var step = endLoc; step >= startLoc; step -= 1) {\n        var currentStepText = fullText.slice(0, step);\n        textNode.textContent = currentStepText;\n\n        if (inRange()) {\n          return step === fullText.length ? {\n            finished: false,\n            reactNode: fullText\n          } : {\n            finished: true,\n            reactNode: currentStepText\n          };\n        }\n      }\n    }\n\n    if (inRange()) {\n      return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n    }\n\n    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n  }\n\n  function measureNode(childNode, index) {\n    var type = childNode.nodeType;\n\n    if (type === ELEMENT_NODE) {\n      // We don't split element, it will keep if whole element can be displayed.\n      appendChildNode(childNode);\n\n      if (inRange()) {\n        return {\n          finished: false,\n          reactNode: contentList[index]\n        };\n      } // Clean up if can not pull in\n\n\n      ellipsisContentHolder.removeChild(childNode);\n      return {\n        finished: true,\n        reactNode: null\n      };\n    }\n\n    if (type === TEXT_NODE) {\n      var fullText = childNode.textContent || '';\n      var textNode = document.createTextNode(fullText);\n      appendChildNode(textNode);\n      return measureText(textNode, fullText);\n    } // Not handle other type of content\n    // PS: This code should not be attached after react 16\n\n\n    return {\n      finished: false,\n      reactNode: null\n    };\n  }\n\n  childNodes.some(function (childNode, index) {\n    var _measureNode = measureNode(childNode, index),\n        finished = _measureNode.finished,\n        reactNode = _measureNode.reactNode;\n\n    if (reactNode) {\n      ellipsisChildren.push(reactNode);\n    }\n\n    return finished;\n  });\n  return {\n    content: ellipsisChildren,\n    text: ellipsisContainer.innerHTML,\n    ellipsis: true\n  };\n});","map":{"version":3,"sources":["typography/util.jsx"],"names":["ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","wrapperStyle","padding","margin","display","lineHeight","match","value","Number","styleNames","Array","style","childList","children","prevChild","ellipsisContainer","document","originStyle","window","originCSS","styleToString","pxToNumber","maxHeight","rows","contentList","mergeChildren","toArray","render","inRange","unmountComponentAtNode","content","text","ellipsis","childNodes","nodeType","fixedNodes","ellipsisChildren","ellipsisContentHolder","ellipsisTextNode","startLoc","endLoc","fullText","length","lastSuccessLoc","midLoc","Math","currentText","textNode","step","currentStepText","finished","reactNode","measureText","type","childNode","appendChildNode","measureNode"],"mappings":"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","sourcesContent":["import { render, unmountComponentAtNode } from 'react-dom';\nimport * as React from 'react';\nimport toArray from 'rc-util/lib/Children/toArray';\n// We only handle element & text node.\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nlet ellipsisContainer;\nconst wrapperStyle = {\n    padding: 0,\n    margin: 0,\n    display: 'inline',\n    lineHeight: 'inherit',\n};\nfunction pxToNumber(value) {\n    if (!value)\n        return 0;\n    const match = value.match(/^\\d*(\\.\\d*)?/);\n    return match ? Number(match[0]) : 0;\n}\nfunction styleToString(style) {\n    // There are some different behavior between Firefox & Chrome.\n    // We have to handle this ourself.\n    const styleNames = Array.prototype.slice.apply(style);\n    return styleNames.map(name => `${name}: ${style.getPropertyValue(name)};`).join('');\n}\nfunction mergeChildren(children) {\n    const childList = [];\n    children.forEach((child) => {\n        const prevChild = childList[childList.length - 1];\n        if (typeof child === 'string' && typeof prevChild === 'string') {\n            childList[childList.length - 1] += child;\n        }\n        else {\n            childList.push(child);\n        }\n    });\n    return childList;\n}\nexport default (originEle, rows, content, fixedContent, ellipsisStr) => {\n    if (!ellipsisContainer) {\n        ellipsisContainer = document.createElement('div');\n        ellipsisContainer.setAttribute('aria-hidden', 'true');\n        document.body.appendChild(ellipsisContainer);\n    }\n    // Get origin style\n    const originStyle = window.getComputedStyle(originEle);\n    const originCSS = styleToString(originStyle);\n    const lineHeight = pxToNumber(originStyle.lineHeight);\n    const maxHeight = lineHeight * (rows + 1) +\n        pxToNumber(originStyle.paddingTop) +\n        pxToNumber(originStyle.paddingBottom);\n    // Set shadow\n    ellipsisContainer.setAttribute('style', originCSS);\n    ellipsisContainer.style.position = 'fixed';\n    ellipsisContainer.style.left = '0';\n    ellipsisContainer.style.height = 'auto';\n    ellipsisContainer.style.minHeight = 'auto';\n    ellipsisContainer.style.maxHeight = 'auto';\n    ellipsisContainer.style.top = '-999999px';\n    ellipsisContainer.style.zIndex = '-1000';\n    // clean up css overflow\n    ellipsisContainer.style.textOverflow = 'clip';\n    ellipsisContainer.style.whiteSpace = 'normal';\n    ellipsisContainer.style.webkitLineClamp = 'none';\n    // Render in the fake container\n    const contentList = mergeChildren(toArray(content));\n    render(<div style={wrapperStyle}>\n      <span style={wrapperStyle}>{contentList}</span>\n      <span style={wrapperStyle}>{fixedContent}</span>\n    </div>, ellipsisContainer); // wrap in an div for old version react\n    // Check if ellipsis in measure div is height enough for content\n    function inRange() {\n        return ellipsisContainer.offsetHeight < maxHeight;\n    }\n    // Skip ellipsis if already match\n    if (inRange()) {\n        unmountComponentAtNode(ellipsisContainer);\n        return { content, text: ellipsisContainer.innerHTML, ellipsis: false };\n    }\n    // We should clone the childNode since they're controlled by React and we can't reuse it without warning\n    const childNodes = Array.prototype.slice\n        .apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes)\n        .filter(({ nodeType }) => nodeType !== COMMENT_NODE);\n    const fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n    unmountComponentAtNode(ellipsisContainer);\n    // ========================= Find match ellipsis content =========================\n    const ellipsisChildren = [];\n    ellipsisContainer.innerHTML = '';\n    // Create origin content holder\n    const ellipsisContentHolder = document.createElement('span');\n    ellipsisContainer.appendChild(ellipsisContentHolder);\n    const ellipsisTextNode = document.createTextNode(ellipsisStr);\n    ellipsisContentHolder.appendChild(ellipsisTextNode);\n    fixedNodes.forEach(childNode => {\n        ellipsisContainer.appendChild(childNode);\n    });\n    // Append before fixed nodes\n    function appendChildNode(node) {\n        ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n    }\n    // Get maximum text\n    function measureText(textNode, fullText, startLoc = 0, endLoc = fullText.length, lastSuccessLoc = 0) {\n        const midLoc = Math.floor((startLoc + endLoc) / 2);\n        const currentText = fullText.slice(0, midLoc);\n        textNode.textContent = currentText;\n        if (startLoc >= endLoc - 1) {\n            // Loop when step is small\n            for (let step = endLoc; step >= startLoc; step -= 1) {\n                const currentStepText = fullText.slice(0, step);\n                textNode.textContent = currentStepText;\n                if (inRange()) {\n                    return step === fullText.length\n                        ? {\n                            finished: false,\n                            reactNode: fullText,\n                        }\n                        : {\n                            finished: true,\n                            reactNode: currentStepText,\n                        };\n                }\n            }\n        }\n        if (inRange()) {\n            return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n        }\n        return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n    }\n    function measureNode(childNode, index) {\n        const type = childNode.nodeType;\n        if (type === ELEMENT_NODE) {\n            // We don't split element, it will keep if whole element can be displayed.\n            appendChildNode(childNode);\n            if (inRange()) {\n                return {\n                    finished: false,\n                    reactNode: contentList[index],\n                };\n            }\n            // Clean up if can not pull in\n            ellipsisContentHolder.removeChild(childNode);\n            return {\n                finished: true,\n                reactNode: null,\n            };\n        }\n        if (type === TEXT_NODE) {\n            const fullText = childNode.textContent || '';\n            const textNode = document.createTextNode(fullText);\n            appendChildNode(textNode);\n            return measureText(textNode, fullText);\n        }\n        // Not handle other type of content\n        // PS: This code should not be attached after react 16\n        return {\n            finished: false,\n            reactNode: null,\n        };\n    }\n    childNodes.some((childNode, index) => {\n        const { finished, reactNode } = measureNode(childNode, index);\n        if (reactNode) {\n            ellipsisChildren.push(reactNode);\n        }\n        return finished;\n    });\n    return {\n        content: ellipsisChildren,\n        text: ellipsisContainer.innerHTML,\n        ellipsis: true,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}